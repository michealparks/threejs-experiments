<title>ThreeJS Experiments: Donut | Micheal Parks</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel='stylesheet' href='css/index.css' />

<a id='back' class='button' href='/threejs-experiments'>Back</a>

<script type='module'>
  if (window !== window.top) window.back.style.display = 'none'
</script>

<canvas></canvas>

<script type='module'>
import { THREE, createCore, createOrbitControls, createSkySphere } from './js/core.js'
import { initXR } from './js/xr.js'
import { loadModels } from './js/loaders.js'
import { postprocessing } from './js/postprocessing.js'
import { randNumInRange, randomPointInCircle } from './js/util.js'
import { COLORS, SHADOW_MAP } from './js/constants.js'

const fire = {
  num: 100,
  dummy: new THREE.Object3D(),
  matrix: new THREE.Matrix4(),
  scaleMatrix: new THREE.Matrix4(),
  embers: [],
  plane: null,
  speed: 0.5,

  init (scene, plane, embers) {
    const { num } = this

    this.plane = plane
    

    for (const ember of embers) {
      ember.matrixAutoUpdate = true
      ember.position.set(0, 0, 0)
      const mesh = new THREE.InstancedMesh(ember.geometry.clone(), ember.material.clone(), num)
      const obj = {
        mesh,
        p: new Float32Array(num * 3),
        r: new Float32Array(num * 3),
        s: new Float32Array(num),
        pv: new Float32Array(num * 3),
        sv: new Float32Array(num * 3)
      }

      mesh.position.set(0, 0.5, 0)

      let i = 0
      while (i < num) {
        this.setPropsAtIndex(i, obj)
        i += 1
      }

      this.embers.push(obj)
      plane.add(mesh)
    }
  },

  setPropsAtIndex (i, ember) {
    const ii = i * 3

    const [px, py] = randomPointInCircle(1.25)

    ember.p[ii + 0] = px
    ember.p[ii + 1] = randNumInRange(0.1, 0.75)
    ember.p[ii + 2] = py

    ember.s[i] = 1.0
    ember.sv[i] = randNumInRange(-0.1, -0.03)

    ember.pv[ii + 0] = randNumInRange(-0.01, 0.05)
    ember.pv[ii + 1] = randNumInRange(0.01, 0.05)
    ember.pv[ii + 2] = randNumInRange(-0.01, 0.05)
  },

  update (dt) {
    const { plane, embers, matrix, scaleMatrix, num, dummy } = this

    const d = dt / 1000

    for (const ember of embers) {
      const { mesh, p, r, s, pv, rv, sv } = ember
      let i = 0
      while (i < num) {
        const ii = i * 3

        
        s[i] += sv[i]

        if (s[i] <= 0.0) {
          this.setPropsAtIndex(i, ember)
        }

        p[ii + 0] += pv[ii + 0]
        p[ii + 1] += pv[ii + 1]
        p[ii + 2] += pv[ii + 2]

        dummy.position.set(p[ii], p[ii + 1], p[ii + 2])
        dummy.scale.set(s[i], s[i], s[i])
        dummy.updateMatrix()

        mesh.setMatrixAt(i, dummy.matrix)
        i += 1
      }

      mesh.instanceMatrix.needsUpdate = true
    }
    
  }
}

const main = async () => {
  const canvas = document.querySelector('canvas')
  const core = createCore({
    alpha: true,
    canvas,
    ambientLight: 0.2,
    camera: { near: 0.1, far: 1000 }
  })
  const { renderer, camera, scene, setAnimationLoop } = core

  const composer = postprocessing.createComposer(renderer, scene, camera)
  const bloomPass = postprocessing.setBloomPass({
    composer,
    threshold: 0,
    strength: 0.0,
    radius: 0.3
  })
  postprocessing.setFxaaPass(composer)


  camera.position.set(15.0, 15.0, 15.0)

  const controls = createOrbitControls({ renderer, camera, rotate: false })

  const handleProgress = (...args) => {
    console.log(args)
  }

  const [gltf] = await loadModels([
    'assets/gltf/FloatingRockScene.glb',
  ], [
    { shadows: true }
  ], handleProgress)

  fire.init(
    scene,
    gltf.getObjectByName('Fire'),
    [
      gltf.getObjectByName('Ember1'),
      gltf.getObjectByName('Ember2'),
      gltf.getObjectByName('Ember3')
    ]
  )

  scene.add(gltf)

  {
    const intensity = 5.0
    const light = new THREE.PointLight(COLORS.warmLight, intensity)
    light.castShadow = true
    light.position.copy(gltf.getObjectByName('Fire').position)
    light.position.y = 1.4
    light.shadow.mapSize.width = SHADOW_MAP.width
    light.shadow.mapSize.height = SHADOW_MAP.height
    light.shadow.radius = 8
    light.shadow.bias = -0.0001
    scene.add(light)
  }

  {
    const intensity = 0.3
    const light = new THREE.HemisphereLight(COLORS.white, intensity)
    light.color.setHSL(0.6, 1, 0.6)
    light.groundColor.setHSL(0.095, 1, 0.75)
    light.position.set(0, 50, 0)
    scene.add(light)
  }

  {
    const intensity = 1.0
    const light = new THREE.DirectionalLight(COLORS.white, intensity)
    light.color.setHSL(0.1, 1, 0.95)
    light.position.set(-1, 1.75, 1)
    light.position.multiplyScalar(30)
    scene.add(light)
  }

  {
    const intensity = 30.0
    const light = new THREE.SpotLight(COLORS.warmLight, intensity)
    light.angle = 70
    light.penumbra = 1

    light.position.set(...Array(3).fill(30))
    // scene.add(light)
  }

  {
    const sphere = createSkySphere({ segments: 64 })
    scene.add(sphere)
  }

  let lastTime = performance.now()
  let dt = 0.0
  const frame = (time) => {
    dt = time - lastTime
    lastTime = time

    fire.update(dt)
    controls.update()
  }

  initXR({ renderer })
  setAnimationLoop({ frame, composer })
}

main()
</script>
