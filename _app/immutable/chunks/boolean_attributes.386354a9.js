function n(){}function t(n){return n()}function e(){return Object.create(null)}function o(n){n.forEach(t)}function r(n){return"function"==typeof n}function u(n,t){return n!=n?t==t:n!==t||n&&"object"==typeof n||"function"==typeof n}function c(n){return 0===Object.keys(n).length}function i(t,e,o){t.$$.on_destroy.push(function(t,...e){if(null==t){for(const n of e)n(void 0);return n}const o=t.subscribe(...e);return o.unsubscribe?()=>o.unsubscribe():o}(e,o))}function f(n,t,e,o){if(n){const r=s(n,t,e,o);return n[0](r)}}function s(n,t,e,o){return n[1]&&o?function(n,t){for(const e in t)n[e]=t[e];return n}(e.ctx.slice(),n[1](o(t))):e.ctx}function a(n,t,e,o){if(n[2]&&o){const r=n[2](o(e));if(void 0===t.dirty)return r;if("object"==typeof r){const n=[],e=Math.max(t.dirty.length,r.length);for(let o=0;o<e;o+=1)n[o]=t.dirty[o]|r[o];return n}return t.dirty|r}return t.dirty}function l(n,t,e,o,r,u){if(r){const c=s(t,e,o,u);n.p(c,r)}}function h(n){if(n.ctx.length>32){const t=[],e=n.ctx.length/32;for(let n=0;n<e;n++)t[n]=-1;return t}return-1}"undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;let d;function p(n){d=n}function g(){if(!d)throw new Error("Function called outside component initialization");return d}function y(n){g().$$.on_mount.push(n)}function b(n){g().$$.after_update.push(n)}const w=[],x=[];let m=[];const $=[],j=Promise.resolve();let E=!1;function _(){E||(E=!0,j.then(S))}function v(){return _(),j}function O(n){m.push(n)}const k=new Set;let z=0;function S(){if(0!==z)return;const n=d;do{try{for(;z<w.length;){const n=w[z];z++,p(n),T(n.$$)}}catch(t){throw w.length=0,z=0,t}for(p(null),w.length=0,z=0;x.length;)x.pop()();for(let n=0;n<m.length;n+=1){const t=m[n];k.has(t)||(k.add(t),t())}m.length=0}while(w.length);for(;$.length;)$.pop()();E=!1,k.clear(),p(n)}function T(n){if(null!==n.fragment){n.update(),o(n.before_update);const t=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,t),n.after_update.forEach(O)}}function q(n){const t=[],e=[];m.forEach((o=>-1===n.indexOf(o)?t.push(o):e.push(o))),e.forEach((n=>n())),m=t}const A=new Set;let F;function M(){F={r:0,c:[],p:F}}function P(){F.r||o(F.c),F=F.p}function B(n,t){n&&n.i&&(A.delete(n),n.i(t))}function C(n,t,e,o){if(n&&n.o){if(A.has(n))return;A.add(n),F.c.push((()=>{A.delete(n),o&&(e&&n.d(1),o())})),n.o(t)}else o&&o()}export{_ as A,C as a,B as b,P as c,b as d,x as e,f,M as g,h,a as i,i as j,e as k,S as l,r as m,n,y as o,c as p,O as q,o as r,u as s,v as t,l as u,q as v,d as w,p as x,t as y,w as z};
